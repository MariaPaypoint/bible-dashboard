[
  {
    "projectId": "ac4d9751-84b5-4512-b921-dd3ca813e496",
    "testId": "1c2276e6-09df-43c7-9217-81d950bdbdad",
    "userId": "e418a408-20f1-7010-c980-6933e30f470c",
    "title": "TC001-Filter anomalies by Voice only",
    "description": "Verify that selecting a Voice filter correctly restricts the anomaly list to show only anomalies matching the selected Voice.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173/anomalies\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password, then click login button to access the application\n        frame = context.pages[-1]\n        # Input username 'admin'\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password 'admin123'\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click login button\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'Anomalies' link in the left navigation menu to go to the anomalies page.\n        frame = context.pages[-1]\n        # Click on the 'Anomalies' link in the left navigation menu\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/ul/li[2]/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the Voice filter dropdown to open the list of available Voices.\n        frame = context.pages[-1]\n        # Click on the 'Select voice' dropdown to open the Voice filter options\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/div/div/div/div/span').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select the first Voice option '[test] Александр Бондаренко (SYNO - ru)' from the dropdown to filter anomalies.\n        frame = context.pages[-1]\n        # Select the Voice '[test] Александр Бондаренко (SYNO - ru)' from the Voice filter dropdown\n        elem = frame.locator('xpath=html/body/div[2]/div/div[2]/div').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=No anomalies found for the selected Voice filter').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: Selecting a Voice filter did not restrict the anomaly list to show only anomalies matching the selected Voice as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test stopped due to inability to select a Voice filter from the dropdown on the Anomalies page. The anomaly list does not update and no anomalies are displayed. This prevents verification of the Voice filter functionality as required by the task.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e418a408-20f1-7010-c980-6933e30f470c/1766006257226518//tmp/test_task/result.webm",
    "created": "2025-12-17T21:14:54.434Z",
    "modified": "2025-12-17T21:17:37.366Z"
  },
  {
    "projectId": "ac4d9751-84b5-4512-b921-dd3ca813e496",
    "testId": "5956635f-abeb-43c4-bcc1-a4ba0b7006e5",
    "userId": "e418a408-20f1-7010-c980-6933e30f470c",
    "title": "TC004-Play anomaly audio snippet with word highlighting",
    "description": "Verify the mini audio player plays the audio snippet and highlights words in synchronization during playback.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173/anomalies\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password, then click login button\n        frame = context.pages[-1]\n        # Input username 'admin'\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password 'admin123'\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click login button\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Anomalies' menu item to go to anomalies page\n        frame = context.pages[-1]\n        # Click on 'Anomalies' menu item to navigate to anomalies page\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/ul/li[2]/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a voice from the 'Select voice' dropdown to load anomalies and enable audio play buttons\n        frame = context.pages[-1]\n        # Click on 'Select voice' dropdown to open options\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/div/div/div/div/span').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a voice from the 'Select voice' dropdown to load anomalies and enable audio play buttons\n        frame = context.pages[-1]\n        # Click on 'Select voice' dropdown to open options\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/div/div/div/div/span').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a voice option from the dropdown to load anomalies and enable audio play buttons\n        frame = context.pages[-1]\n        # Select the first voice option '[test] Александр Бондаренко (SYNO - ru)' from the dropdown\n        elem = frame.locator('xpath=html/body/div[4]/div/ul/li').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the play button on the first anomaly in the table to trigger the mini audio player and verify playback and word highlighting.\n        frame = context.pages[-1]\n        # Click the play button on the first anomaly in the table\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/div[2]/div[2]/table/tbody/tr/td[8]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Select voice' dropdown to open voice options\n        frame = context.pages[-1]\n        # Click on 'Select voice' dropdown to open voice options\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/div/div/div/div/span').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select the first voice option '[test] Александр Бондаренко (SYNO - ru)' from the dropdown to load anomalies\n        frame = context.pages[-1]\n        # Select the first voice option '[test] Александр Бондаренко (SYNO - ru)' from the dropdown\n        elem = frame.locator('xpath=html/body/div[4]/div/ul/li').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click the play button on the first anomaly in the table to trigger the mini audio player and verify playback and word highlighting.\n        frame = context.pages[-1]\n        # Click the play button on the first anomaly in the table\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/div[2]/div[2]/table/tbody/tr/td[8]/div/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on 'Select voice' dropdown to open voice options\n        frame = context.pages[-1]\n        # Click on 'Select voice' dropdown to open voice options\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/div/div/div/div/span').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Try selecting a different voice option from the 'Select voice' dropdown to find anomalies with audio play buttons\n        frame = context.pages[-1]\n        # Click on 'Select voice' dropdown to open voice options\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/div/div/div/div/span').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        frame = context.pages[-1]\n        # Select the first voice option '[test] \"Faith Comes By Hearing\" (New Testament only) (WEBUS - en)' from the dropdown\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/div[2]/div[2]/table/thead/tr/th[6]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Audio Playback Completed Successfully').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test case failed: The mini audio player did not play the audio snippet or highlight words in synchronization during playback as expected.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test cannot proceed because no voices can be selected or no anomalies are loaded, preventing the mini audio player from being tested. Please investigate the voice selection and anomalies loading functionality.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e418a408-20f1-7010-c980-6933e30f470c/176600645283913//tmp/test_task/result.webm",
    "created": "2025-12-17T21:14:54.441Z",
    "modified": "2025-12-17T21:20:52.960Z"
  },
  {
    "projectId": "ac4d9751-84b5-4512-b921-dd3ca813e496",
    "testId": "27d75e17-6fe6-4fae-b214-ab3f2ddcb80f",
    "userId": "e418a408-20f1-7010-c980-6933e30f470c",
    "title": "TC008-Persisting anomaly status updates",
    "description": "Verify that updating anomaly status (e.g., to confirmed error or alignment correct) persists changes accurately in the backend.",
    "code": "import asyncio\nfrom playwright import async_api\nfrom playwright.async_api import expect\n\nasync def run_test():\n    pw = None\n    browser = None\n    context = None\n    \n    try:\n        # Start a Playwright session in asynchronous mode\n        pw = await async_api.async_playwright().start()\n        \n        # Launch a Chromium browser in headless mode with custom arguments\n        browser = await pw.chromium.launch(\n            headless=True,\n            args=[\n                \"--window-size=1280,720\",         # Set the browser window size\n                \"--disable-dev-shm-usage\",        # Avoid using /dev/shm which can cause issues in containers\n                \"--ipc=host\",                     # Use host-level IPC for better stability\n                \"--single-process\"                # Run the browser in a single process mode\n            ],\n        )\n        \n        # Create a new browser context (like an incognito window)\n        context = await browser.new_context()\n        context.set_default_timeout(5000)\n        \n        # Open a new page in the browser context\n        page = await context.new_page()\n        \n        # Navigate to your target URL and wait until the network request is committed\n        await page.goto(\"http://localhost:5173/anomalies\", wait_until=\"commit\", timeout=10000)\n        \n        # Wait for the main page to reach DOMContentLoaded state (optional for stability)\n        try:\n            await page.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n        except async_api.Error:\n            pass\n        \n        # Iterate through all iframes and wait for them to load as well\n        for frame in page.frames:\n            try:\n                await frame.wait_for_load_state(\"domcontentloaded\", timeout=3000)\n            except async_api.Error:\n                pass\n        \n        # Interact with the page elements to simulate user flow\n        # -> Input username and password, then click login button to access the application.\n        frame = context.pages[-1]\n        # Input username 'admin'\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/form/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin')\n        \n\n        frame = context.pages[-1]\n        # Input password 'admin123'\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/form/div[2]/div/input').nth(0)\n        await page.wait_for_timeout(3000); await elem.fill('admin123')\n        \n\n        frame = context.pages[-1]\n        # Click login button\n        elem = frame.locator('xpath=html/body/div/div/div/div[2]/form/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'Anomalies' menu item to navigate to the anomalies page.\n        frame = context.pages[-1]\n        # Click on 'Anomalies' menu item to navigate to anomalies page\n        elem = frame.locator('xpath=html/body/div/div/div/div/div[2]/ul/li[2]/ul/li[2]/a').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a voice from the 'Select voice' dropdown to load anomalies.\n        frame = context.pages[-1]\n        # Click on 'Select voice' dropdown to open options\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/div/div/div/div/span').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the 'Select voice' dropdown to open the list of voices and select one to load anomalies.\n        frame = context.pages[-1]\n        # Click on 'Select voice' dropdown to open voice options\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/div/div/div/div/span').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Select a voice from the list to load anomalies for that voice.\n        frame = context.pages[-1]\n        # Select the first voice option '[test] Александр Бондаренко (SYNO - ru)' from the dropdown\n        elem = frame.locator('xpath=html/body/div[4]/div/ul/li').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Click on the status dropdown of the first anomaly with code 31626 to change its status.\n        frame = context.pages[-1]\n        # Click on the status dropdown of the anomaly with code 31626 to open status options\n        elem = frame.locator('xpath=html/body/div/div/div[2]/div/div/div[3]/div[2]/div[2]/table/tbody/tr[4]/td[7]/button').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # -> Change the status of anomaly 31626 to 'Confirmed' by clicking the 'Confirmed' option in the dropdown.\n        frame = context.pages[-1]\n        # Select 'Confirmed' status option for anomaly 31626\n        elem = frame.locator('xpath=html/body/div[6]/div/div/ul/li[2]').nth(0)\n        await page.wait_for_timeout(3000); await elem.click(timeout=5000)\n        \n\n        # --> Assertions to verify final state\n        frame = context.pages[-1]\n        try:\n            await expect(frame.locator('text=Status update successful').first).to_be_visible(timeout=1000)\n        except AssertionError:\n            raise AssertionError(\"Test failed: Updating anomaly status did not persist as expected according to the test plan.\")\n        await asyncio.sleep(5)\n    \n    finally:\n        if context:\n            await context.close()\n        if browser:\n            await browser.close()\n        if pw:\n            await pw.stop()\n            \nasyncio.run(run_test())\n    ",
    "testStatus": "FAILED",
    "testError": "Test stopped due to inability to load anomalies and update status. Reported issue for investigation.",
    "testType": "FRONTEND",
    "createFrom": "mcp",
    "testVisualization": "https://testsprite-videos.s3.us-east-1.amazonaws.com/e418a408-20f1-7010-c980-6933e30f470c/1766006335184357//tmp/test_task/result.webm",
    "created": "2025-12-17T21:14:54.448Z",
    "modified": "2025-12-17T21:18:55.309Z"
  }
]
